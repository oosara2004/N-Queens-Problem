import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class NQueensTest {
    public static void main(String[] args) {
        testAlgorithms();
    }

    public static void testAlgorithms() {
        int[] nValues = { 8, 16, 32, 64 };

        for (int n : nValues) {
            System.out.println("========== Testing N = " + n + " ==========");
            TestBacktracking(n);
            TestForwardChecking(n);
            TestMAC(n);
        }
    }

    public static void TestBacktracking(int n) {
        int board[] = generateRandomStartState(n);
        System.out.println("========== Backtracking ==========");
        int[] startStateCopy = Arrays.copyOf(board, board.length);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Boolean> future = executor.submit(() -> BT.Backtracking(board));

        long start = System.nanoTime();
        boolean solved = false;

        try {
            solved = future.get(20, TimeUnit.MINUTES);
        } catch (TimeoutException e) {
            System.out.println("Time limit exceeded! Stopping Backtracking.");
            future.cancel(true);
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.nanoTime();
        executor.shutdownNow();

        System.out.println("Start State = " + Arrays.toString(startStateCopy));
        System.out.println("Solved = " + solved);
        System.out.println("Time = " + (end - start) / 1_000_000.0 + " ms");
        System.out.println();
    }

    public static void TestForwardChecking(int n) {
        int[] board = generateRandomStartState(n);
        int[] startStateCopy = Arrays.copyOf(board, board.length);
        System.out.println("========== Forward Checking ==========");

        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future<Boolean> future = executor.submit(() -> ForwardChecking.intilize(board));

        long start = System.nanoTime();
        boolean solved = false;

        try {
            solved = future.get(20, TimeUnit.MINUTES);
        } catch (TimeoutException e) {
            System.out.println("Time limit exceeded! Stopping Forward Checking.");
            future.cancel(true);
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.nanoTime();
        executor.shutdownNow();

        System.out.println("ConstraintCheckCounter(ForwardChecking) = " + ForwardChecking.constraintChecks);

        System.out.println("Start State = " + Arrays.toString(startStateCopy));
        System.out.println("Solved = " + solved);
        System.out.println("Time = " + (end - start) / 1_000_000.0 + " ms");
        System.out.println();
    }

    public static void TestMAC(int n) {
        int board[] = generateRandomStartState(n);
        int[] startStateCopy = Arrays.copyOf(board, board.length);

        System.out.println("========== MAC Checking ==========");

        long start = System.nanoTime();
        boolean solved = MAC.solve(board);
        long end = System.nanoTime();

        System.out.println("Start State = " + Arrays.toString(startStateCopy));
        System.out.println("Solved = " + solved);
        System.out.println("Time = " + (end - start) / 1_000_000.0 + " ms\n");

    }

    public static int[] generateRandomStartState(int n) {
        int[] board = new int[n];
        Random rand = new Random();
        for (int i = 0; i < n; i++)
            board[i] = rand.nextInt(n);
        return board;
    }

}
